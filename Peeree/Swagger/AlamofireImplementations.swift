// AlamofireImplementations.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation

typealias CompletionHandler = () -> Void

open class MySessionDelegate : NSObject, URLSessionDelegate, URLSessionTaskDelegate, URLSessionDataDelegate, URLSessionDownloadDelegate, URLSessionStreamDelegate {
    var completionHandlers: [String: CompletionHandler] = [:]
    
    static var cred: URLCredential?
    static var space: URLProtectionSpace?
    
    open func createAndConfigureSession() {
        // Creating session configurations
        let defaultConfiguration = URLSessionConfiguration.default
        defaultConfiguration.httpShouldUsePipelining = true
        defaultConfiguration.tlsMinimumSupportedProtocol = .tlsProtocol12
        defaultConfiguration.tlsMaximumSupportedProtocol = .tlsProtocol12
        defaultConfiguration.timeoutIntervalForRequest = 1.0 // TODO make bigger, only for testing so low
        if let credential = MySessionDelegate.cred, let space = MySessionDelegate.space {
            defaultConfiguration.urlCredentialStorage!.setDefaultCredential(credential, for: space)
        }
//        let ephemeralConfiguration = URLSessionConfiguration.ephemeral
//        let backgroundConfiguration = URLSessionConfiguration.backgroundSessionConfiguration("com.peeree.networking.background")
        
//        // Configuring caching behavior for the default session
//        let cachesDirectoryURL = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).first!
//        let cacheURL = try! cachesDirectoryURL.appendingPathComponent("MyCache")
//        var diskPath = cacheURL.path
//        
//        /* Note:
//         iOS requires the cache path to be
//         a path relative to the ~/Library/Caches directory,
//         but OS X expects an absolute path.
//         */
//        #if os(OSX)
//            diskPath = cacheURL.absoluteString
//        #endif
//        
//        let cache = URLCache(memoryCapacity:16384, diskCapacity: 268435456, diskPath: diskPath)
//        defaultConfiguration.urlCache = cache
//        defaultConfiguration.requestCachePolicy = .useProtocolCachePolicy
        // Creating sessions
        let delegate = self
        let operationQueue = OperationQueue.main
        
        let defaultSession = URLSession(configuration: defaultConfiguration, delegate: delegate, delegateQueue: operationQueue)
//        let ephemeralSession = URLSession(configuration: ephemeralConfiguration, delegate: delegate, delegateQueue: operationQueue)
//        let backgroundSession = URLSession(configuration: backgroundConfiguration, delegate: delegate, delegateQueue: operationQueue)
        
//        ephemeralConfiguration.allowsCellularAccess = false
//        let ephemeralSessionWiFiOnly = URLSession(configuration: ephemeralConfiguration, delegate: delegate, delegateQueue: operationQueue)
//        
//        let sessionWithoutADelegate = URLSession(configuration: defaultConfiguration)
        if let url = URL(string: "\(SwaggerClientAPI.basePath)/account?publicKey=Public%20Key") {
            (defaultSession.dataTask(with: url) { (data, response, error) in
                if let error = error {
                    print("Error: \(error)")
                } else if let response = response,
                    let data = data,
                    let string = String(data: data, encoding: .utf8) {
                    print("Response: \(response)")
                    print("DATA:\n\(string)\nEND DATA\n")
                }
            }).resume()
        }
    }
    
    public func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        guard challenge.previousFailureCount == 0 else {
            challenge.sender?.cancel(challenge)
            // Inform the user that something failed
            completionHandler(.cancelAuthenticationChallenge, nil)
            return
        }
        
        guard let trust = challenge.protectionSpace.serverTrust else {
            NSLog("no server trust found")
            challenge.sender?.cancel(challenge)
            // Inform the user that something failed
            completionHandler(.cancelAuthenticationChallenge, nil)
            return
        }
        
        guard let url = Bundle.main.url(forResource: "cacert", withExtension: "der") else {
            NSLog("could not find server certificate file in bundle.")
            return
        }
        var data: Data
        do {
            data = try Data(contentsOf: url)
        } catch {
            NSLog("unable to read certificate file: \(error.localizedDescription)")
            return
        }
        
        guard let certificate = SecCertificateCreateWithData(kCFAllocatorDefault, data as CFData) else {
            NSLog("server certificate data is not in DER format.")
            return
        }
        
        var status = SecTrustSetAnchorCertificates(trust, [certificate] as CFArray)
        guard status == errSecSuccess else {
            NSLog("adding anchor certificate failed with code \(status).")
            return
        }
        
        var result: SecTrustResultType = .otherError
        status = SecTrustEvaluate(trust, &result)
        guard status == errSecSuccess else {
            NSLog("evaluating trust failed with code \(status).")
            challenge.sender?.cancel(challenge)
            // Inform the user that something failed
            completionHandler(.cancelAuthenticationChallenge, nil)
            return
        }
        
        guard result == .proceed else {
            NSLog("server certificate not trusted, result code: \(result.rawValue).")
            challenge.sender?.cancel(challenge)
            // Inform the user that something failed
            completionHandler(.cancelAuthenticationChallenge, nil)
            return
        }
        
        let credential = URLCredential(trust: trust)
        challenge.sender?.use(credential, for: challenge)
        
        completionHandler(.useCredential, credential)
        
//        URLCredentialStorage.shared.setDefaultCredential(credential, for: challenge.protectionSpace)
//        MySessionDelegate.cred = credential
//        MySessionDelegate.space = challenge.protectionSpace
//        completionHandler(.performDefaultHandling,nil)
    }
    
    public func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {
        
    }
}

class AlamofireRequestBuilderFactory: RequestBuilderFactory {
    func getBuilder<T>() -> RequestBuilder<T>.Type {
        return AlamofireRequestBuilder<T>.self
    }
}

// Store manager to retain its reference
private var managerStore: [String: URLSession] = [:]

class DebugCredentialAcceptor : NSObject, URLSessionDelegate {
    public func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        guard challenge.previousFailureCount == 0 else {
            challenge.sender?.cancel(challenge)
            // Inform the user that something failed
            completionHandler(.cancelAuthenticationChallenge, nil)
            return
        }
        
        if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
            if challenge.protectionSpace.host == "192.168.12.190" {
                // for debug only!
                
                guard let trust = challenge.protectionSpace.serverTrust else {
                    NSLog("no server trust found")
                    challenge.sender?.cancel(challenge)
                    // Inform the user that something failed
                    completionHandler(.cancelAuthenticationChallenge, nil)
                    return
                }
                let cred = URLCredential(trust: trust)
                completionHandler(.useCredential, cred);
            }
        }
    }
}

open class AlamofireRequestBuilder<T>: RequestBuilder<T> {
    required public init(method: HTTPMethod, url: URL, parameters: [String : Any]?, isBody: Bool, headers: [String : String] = [:]) {
        super.init(method: method, url: url, parameters: parameters, isBody: isBody, headers: headers)
    }

    /**
     May be overridden by a subclass if you want to control the session
     configuration.
     */
    open func createSessionManager() -> URLSession {
        let configuration = URLSessionConfiguration.default
        configuration.httpAdditionalHeaders = buildHeaders()
        configuration.httpShouldUsePipelining = true
        configuration.tlsMinimumSupportedProtocol = .tlsProtocol12
        configuration.tlsMaximumSupportedProtocol = .tlsProtocol12
        configuration.timeoutIntervalForRequest = 1.0 // TODO make bigger, only for testing so low
//        configuration.urlCredentialStorage = URLCredentialStorage.shared
        if let t = configuration.urlCredentialStorage {
            let s = URLProtectionSpace(host: SwaggerClientAPI.host, port: 0, protocol: SwaggerClientAPI.`protocol`, realm: nil, authenticationMethod: NSURLAuthenticationMethodServerTrust)
            if let c = t.defaultCredential(for: s) {
                print("\(c)")
            }
        }
        
        #if true // adfs
        return URLSession(configuration: configuration, delegate: DebugCredentialAcceptor(), delegateQueue: nil)
        #else
        return URLSession(configuration: configuration)
        #endif
    }

    /**
     May be overridden by a subclass if you want to control the Content-Type
     that is given to an uploaded form part.

     Return nil to use the default behavior (inferring the Content-Type from
     the file extension).  Return the desired Content-Type otherwise.
     */
    open func contentTypeForFormPart(fileURL: URL) -> String? {
        return nil
    }

    /**
     May be overridden by a subclass if you want to control the request
     configuration (e.g. to override the cache policy).
     */
    open func makeRequest(manager: URLSession, method: HTTPMethod) -> URLRequest {
        var request = URLRequest(url: url)
        request.httpMethod = method.rawValue
        request.allowsCellularAccess = true
        request.httpShouldHandleCookies = false
        for header in self.headers {
            request.setValue(header.value, forHTTPHeaderField: header.key)
        }
        return request
    }

    override open func execute(_ completion: @escaping (_ response: Response<T>?, _ error: Error?) -> Void) {
        let managerId:String = UUID().uuidString
        // Create a new manager for each request to customize its request header
        let manager = createSessionManager()
        managerStore[managerId] = manager

        let fileKeys = parameters == nil ? [] : parameters!.filter { $1 is NSURL } .map { $0.0 }

        if fileKeys.count > 0 {
//            manager.upload(multipartFormData: { mpForm in
//                for (k, v) in self.parameters! {
//                    switch v {
//                    case let fileURL as URL:
//                        if let mimeType = self.contentTypeForFormPart(fileURL: fileURL) {
//                            mpForm.append(fileURL, withName: k, fileName: fileURL.lastPathComponent, mimeType: mimeType)
//                        }
//                        else {
//                            mpForm.append(fileURL, withName: k)
//                        }
//                        break
//                    case let string as String:
//                        mpForm.append(string.data(using: String.Encoding.utf8)!, withName: k)
//                        break
//                    case let number as NSNumber:
//                        mpForm.append(number.stringValue.data(using: String.Encoding.utf8)!, withName: k)
//                        break
//                    default:
//                        fatalError("Unprocessable value \(v) with key \(k)")
//                        break
//                    }
//                }
//                }, to: URLString, method: method, headers: nil, encodingCompletion: { encodingResult in
//                switch encodingResult {
//                case .success(let upload, _, _):
//                    if let onProgressReady = self.onProgressReady {
//                        onProgressReady(upload.progress)
//                    }
//                    self.processRequest(request: upload, managerId, completion)
//                case .failure(let encodingError):
//                    completion(nil, ErrorResponse.Error(415, nil, encodingError))
//                }
//            })
        } else {
            let request = makeRequest(manager: manager, method: method)
//            if let onProgressReady = self.onProgressReady {
//                onProgressReady(request.progress)
//            }
            processRequest(manager: manager, request: request, managerId, completion)
        }

    }

    private func processRequest(manager: URLSession, request: URLRequest, _ managerId: String, _ completion: @escaping (_ response: Response<T>?, _ error: Error?) -> Void) {
//        if let credential = self.credential {
//            request.authenticate(usingCredential: credential)
//        }

        let cleanupRequest = {
            _ = managerStore.removeValue(forKey: managerId)
        }
        
//        let validatedRequest = request.validate()
        
        let invalidResponseError = NSError(domain: "Peeree", code: -1, userInfo: [NSLocalizedDescriptionKey : NSLocalizedString("Invalid response.", comment: "The Peeree Server sent invalid response data.")])
        let httpStatusError = NSError(domain: "Peeree", code: -1, userInfo: [NSLocalizedDescriptionKey : NSLocalizedString("HTTP error.", comment: "The Peeree Server sent a response with code 4xx or 5xx.")])
        
        (manager.dataTask(with: request) { (data, response, error) in
            cleanupRequest()
            if let error = error {
                completion(nil, ErrorResponse.Error((response as? HTTPURLResponse)?.statusCode ?? -1, data, error))
            } else if let httpResponse = response as? HTTPURLResponse {
                guard !httpResponse.isFailure else {
                    completion(nil, ErrorResponse.Error(httpResponse.statusCode, data, httpStatusError))
                    return
                }
                
                switch T.self {
                case is String.Type:
                    var body: T?
                    if data != nil {
                        body = String(data: data!, encoding: .utf8) as? T
                    } else {
                        body = "" as? T
                    }
                    completion(Response(response: httpResponse, body: body), nil)
                case is Void.Type:
                    completion(Response(response: httpResponse, body: nil), nil)
                case is Data.Type:
                    completion(Response(response: httpResponse, body: data as? T), nil)
                default:
                    // handle HTTP 204 No Content
                    // NSNull would crash decoders
                    if httpResponse.statusCode == 204 || data == nil {
                        completion(Response(response: httpResponse, body: nil), nil)
                        return
                    }
                    
                    if () is T {
                        completion(Response(response: httpResponse, body: (() as! T)), nil)
                        return
                    }
                    do {
                        let json: Any = try JSONSerialization.jsonObject(with: data!, options: .allowFragments)
                        let body = Decoders.decode(clazz: T.self, source: json as AnyObject)
                        completion(Response(response: httpResponse, body: body), nil)
                    } catch {
                        if "" is T {
                            // swagger-parser currently doesn't support void, which will be fixed in future swagger-parser release
                            // https://github.com/swagger-api/swagger-parser/pull/34
                            completion(Response(response: httpResponse, body: ("" as! T)), nil)
                        } else {
                            completion(nil, ErrorResponse.Error(-1, data, invalidResponseError))
                        }
                    }
                }
            } else {
                completion(nil, ErrorResponse.Error(-1, data, invalidResponseError))
            }
        }).resume()
    }
    
    private func buildHeaders() -> [String: String] {
//        var httpHeaders = SessionManager.defaultHTTPHeaders
//        for (key, value) in self.headers {
//            httpHeaders[key] = value
//        }
//        return httpHeaders
        return self.headers
    }
}
